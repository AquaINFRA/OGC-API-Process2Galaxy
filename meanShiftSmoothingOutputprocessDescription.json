{
  "id": ["OTB.MeanShiftSmoothing"],
  "title": ["This application smooths an image using the MeanShift algorithm."],
  "description": ["MeanShift [1,2,3] is an iterative edge-preserving image smoothing algorithm often used in image processing and as a first step for image segmentation. The MeanShift algorithm can be applied to multispectral images.At first iteration, for any given pixel of the input image, the filtered value correspond to the average spectral signature of neighborhood pixels that are both spatially closer than the spatial radius parameter (spatialr) and with spectral signature that have an euclidean distance to the input pixel lower than the range radius (ranger), that is, pixels that are both close in space and in spectral signatures. Subsequent iterations will repeat this process by considering that the pixel signature corresponds to the average spectral signature computed during previous iteration, and that the pixel position corresponds to the average position of pixels used to compute the average signature.The algorithm stops when the maximum number of iterations (maxiter) is reached, or when the position and spectral signature does not change much between iterations, according to the convergence threshold (thres). If the modesearch option is used then convergence will also stops if the spatial position reaches a pixel that has already converged. This will speed-up convergence, at the expense of stability of the result.The application outputs the image of the final averaged spectral signatures (fout), and can also optionally output the 2D displacement field between input pixel position and final pixel position after convergence (foutpos).Note that computing an euclidean distance between spectral signatures may be inaccurate and that techniques such as color space transform or image normalisation could be applied before using this application. Also note that most satellite images noise model is not gaussian, since noise variance linearly depends on radiance (the higher the radiance, the higher the noise variance). To account for such noise model, the application provides the range radius ramp option (rangeramp), which will vary the range radius linearly with the central pixel intensity. Default value is 1. (no ramp).This application is the first step of the large scale MeanShift method depicted in [4]. Both outputs (fout and foutpos) can be passed to the large scale MeanShift segmentation application [5]. If the application is used for large scale MeanShift, modesearch option should be off."],
  "mutable": [false],
  "version": ["1.0.0"],
  "jobControlOptions": ["sync-execute", "async-execute", "dismiss"],
  "outputTransmission": ["value", "reference"],
  "links": [
    {
      "rel": "http://www.opengis.net/def/rel/ogc/1.0/execute",
      "type": "application/json",
      "title": "Execute End Point",
      "href": "https://ospd.geolabs.fr:8300/ogc-api/processes/OTB.MeanShiftSmoothing/execution"
    },
    {
      "rel": "alternate",
      "type": "text/html",
      "title": "Execute End Point",
      "href": "https://ospd.geolabs.fr:8300/ogc-api/processes/OTB.MeanShiftSmoothing/execution.html"
    }
  ],
  "inputs": {
    "in": {
      "title": ["The input image can be any single or multiband image. Beware of pontential imbalance between bands ranges as it may alter euclidean distance."],
      "description": ["The input image can be any single or multiband image. Beware of pontential imbalance between bands ranges as it may alter euclidean distance."],
      "extended-schema": {
        "oneOf": [
          {
            "allOf": [
              {
                "$ref": "http://zoo-project.org/dl/link.json",
                "properties": {
                  "type": {
                    "enum": {}
                  }
                }
              },
              {
                "type": "object",
                "properties": {
                  "type": {
                    "enum": ["image/tiff", "image/jpeg", "image/png"]
                  }
                }
              }
            ],
            "required": {},
            "properties": {
              "value": {
                "oneOf": {}
              }
            }
          },
          {
            "allOf": {},
            "type": "object",
            "required": ["value"],
            "properties": {
              "value": {
                "oneOf": [
                  {
                    "type": "string",
                    "contentEncoding": "base64",
                    "contentMediaType": "image/tiff"
                  },
                  {
                    "type": "string",
                    "contentEncoding": "base64",
                    "contentMediaType": "image/jpeg"
                  },
                  {
                    "type": "string",
                    "contentEncoding": "base64",
                    "contentMediaType": "image/png"
                  }
                ]
              }
            }
          }
        ]
      },
      "schema": {
        "oneOf": [
          {
            "type": "string",
            "contentEncoding": "base64",
            "contentMediaType": "image/tiff"
          },
          {
            "type": "string",
            "contentEncoding": "base64",
            "contentMediaType": "image/jpeg"
          },
          {
            "type": "string",
            "contentEncoding": "base64",
            "contentMediaType": "image/png"
          }
        ]
      }
    },
    "fout": {
      "title": ["This output image contains the final average spectral signatures of each pixel. The output type should be at least as wide as the input image type. Floating point encoding is advised. This output can be used as input image (in) of the LSMSSegmentation application [4,5]."],
      "description": ["This output image contains the final average spectral signatures of each pixel. The output type should be at least as wide as the input image type. Floating point encoding is advised. This output can be used as input image (in) of the LSMSSegmentation application [4,5]."],
      "schema": {
        "type": ["string"],
        "default": ["float"],
        "enum": ["uint8", "uint16", "int16", "int32", "int32", "float", "double"]
      }
    },
    "foutpos": {
      "title": ["This output image contains the 2D displacement between the input pixel spatial position and the final position after convergence. Floating point encoding is mandatory. This output can be used as input image (in) of the LSMSSegmentation application [4,5]."],
      "description": ["This output image contains the 2D displacement between the input pixel spatial position and the final position after convergence. Floating point encoding is mandatory. This output can be used as input image (in) of the LSMSSegmentation application [4,5]."],
      "schema": {
        "type": ["string"],
        "default": ["float"],
        "enum": ["uint8", "uint16", "int16", "int32", "int32", "float", "double"],
        "nullable": [true]
      }
    },
    "ram": {
      "title": ["Available memory for processing (in MB)"],
      "description": ["Available memory for processing (in MB)"],
      "schema": {
        "type": ["integer"],
        "default": [128],
        "nullable": [true]
      }
    },
    "spatialr": {
      "title": ["Radius of the spatial neighborhood for averaging. Higher values will result in more smoothing and higher processing time."],
      "description": ["Radius of the spatial neighborhood for averaging. Higher values will result in more smoothing and higher processing time."],
      "schema": {
        "type": ["integer"],
        "default": [5],
        "nullable": [true]
      }
    },
    "ranger": {
      "title": ["Threshold on spectral signature euclidean distance (expressed in radiometry unit) to consider neighborhood pixel for averaging. Higher values will be less edge-preserving (more similar to simple average in neighborhood), whereas lower values will result in less noise smoothing. Note that this parameter has no effect on processing time."],
      "description": ["Threshold on spectral signature euclidean distance (expressed in radiometry unit) to consider neighborhood pixel for averaging. Higher values will be less edge-preserving (more similar to simple average in neighborhood), whereas lower values will result in less noise smoothing. Note that this parameter has no effect on processing time."],
      "schema": {
        "type": ["number"],
        "default": [15],
        "format": ["double"],
        "nullable": [true]
      }
    },
    "thres": {
      "title": ["Algorithm will stop if update of average spectral signature and spatial position is below this threshold."],
      "description": ["Algorithm will stop if update of average spectral signature and spatial position is below this threshold."],
      "schema": {
        "type": ["number"],
        "default": [0.1],
        "format": ["double"],
        "nullable": [true]
      }
    },
    "maxiter": {
      "title": ["Algorithm will stop if convergence threshold is not met after the maximum number of iterations."],
      "description": ["Algorithm will stop if convergence threshold is not met after the maximum number of iterations."],
      "schema": {
        "type": ["integer"],
        "default": [100],
        "nullable": [true]
      }
    },
    "rangeramp": {
      "title": ["Vary the range radius linearly with the central pixel intensity (experimental)."],
      "description": ["Vary the range radius linearly with the central pixel intensity (experimental)."],
      "schema": {
        "type": ["number"],
        "default": [0],
        "format": ["double"],
        "nullable": [true]
      }
    },
    "modesearch": {
      "title": ["If activated pixel iterative convergence is stopped if the path crosses an already converged pixel. Be careful, with this option, the result will slightly depend on thread number and the results will not be stable (see [4] for more details)."],
      "description": ["If activated pixel iterative convergence is stopped if the path crosses an already converged pixel. Be careful, with this option, the result will slightly depend on thread number and the results will not be stable (see [4] for more details)."],
      "schema": {
        "type": ["boolean"],
        "default": [false]
      }
    }
  },
  "outputs": {
    "fout": {
      "title": ["This output image contains the final average spectral signatures of each pixel. The output type should be at least as wide as the input image type. Floating point encoding is advised. This output can be used as input image (in) of the LSMSSegmentation application [4,5]."],
      "description": ["This output image contains the final average spectral signatures of each pixel. The output type should be at least as wide as the input image type. Floating point encoding is advised. This output can be used as input image (in) of the LSMSSegmentation application [4,5]."],
      "extended-schema": {
        "oneOf": [
          {
            "allOf": [
              {
                "$ref": "http://zoo-project.org/dl/link.json",
                "properties": {
                  "type": {
                    "enum": {}
                  }
                }
              },
              {
                "type": "object",
                "properties": {
                  "type": {
                    "enum": ["image/tiff", "image/jpeg", "image/png"]
                  }
                }
              }
            ],
            "required": {},
            "properties": {
              "value": {
                "oneOf": {}
              }
            }
          },
          {
            "allOf": {},
            "type": "object",
            "required": ["value"],
            "properties": {
              "value": {
                "oneOf": [
                  {
                    "type": "string",
                    "contentEncoding": "base64",
                    "contentMediaType": "image/tiff"
                  },
                  {
                    "type": "string",
                    "contentEncoding": "base64",
                    "contentMediaType": "image/jpeg"
                  },
                  {
                    "type": "string",
                    "contentEncoding": "base64",
                    "contentMediaType": "image/png"
                  }
                ]
              }
            }
          }
        ]
      },
      "schema": {
        "oneOf": [
          {
            "type": "string",
            "contentEncoding": "base64",
            "contentMediaType": "image/tiff"
          },
          {
            "type": "string",
            "contentEncoding": "base64",
            "contentMediaType": "image/jpeg"
          },
          {
            "type": "string",
            "contentEncoding": "base64",
            "contentMediaType": "image/png"
          }
        ]
      }
    },
    "foutpos": {
      "title": ["This output image contains the 2D displacement between the input pixel spatial position and the final position after convergence. Floating point encoding is mandatory. This output can be used as input image (in) of the LSMSSegmentation application [4,5]."],
      "description": ["This output image contains the 2D displacement between the input pixel spatial position and the final position after convergence. Floating point encoding is mandatory. This output can be used as input image (in) of the LSMSSegmentation application [4,5]."],
      "extended-schema": {
        "oneOf": [
          {
            "allOf": [
              {
                "$ref": "http://zoo-project.org/dl/link.json",
                "properties": {
                  "type": {
                    "enum": {}
                  }
                }
              },
              {
                "type": "object",
                "properties": {
                  "type": {
                    "enum": ["image/tiff", "image/jpeg", "image/png"]
                  }
                }
              }
            ],
            "required": {},
            "properties": {
              "value": {
                "oneOf": {}
              }
            }
          },
          {
            "allOf": {},
            "type": "object",
            "required": ["value"],
            "properties": {
              "value": {
                "oneOf": [
                  {
                    "type": "string",
                    "contentEncoding": "base64",
                    "contentMediaType": "image/tiff"
                  },
                  {
                    "type": "string",
                    "contentEncoding": "base64",
                    "contentMediaType": "image/jpeg"
                  },
                  {
                    "type": "string",
                    "contentEncoding": "base64",
                    "contentMediaType": "image/png"
                  }
                ]
              }
            }
          }
        ]
      },
      "schema": {
        "oneOf": [
          {
            "type": "string",
            "contentEncoding": "base64",
            "contentMediaType": "image/tiff"
          },
          {
            "type": "string",
            "contentEncoding": "base64",
            "contentMediaType": "image/jpeg"
          },
          {
            "type": "string",
            "contentEncoding": "base64",
            "contentMediaType": "image/png"
          }
        ]
      }
    }
  }
} 
